ПРОСТЫЕ И ЗАВИСИМЫЕ ТИПЫ

# Введение

Внимателю читателя предлагается введение в некоторые разделы теории типов (Simply-typed lambda calculus, STLC и Dependent type theory, DTT). Для понимания нижеследующего текста потребуется минимум знаний - линейная алгебра, основы теории групп, основы теории вычислимости и, желательно, практический опыт программирования. 

# Язык суждений

Для записи аксиом и определений мы будем использовать язык суждений. Суждения бывают четырёх видов:

1) Определение типа:

    Expr type

Это говорит нам о том, что Expr является типом.

2) Определение значения:

    expr: Expr

Это означает, что значение expr имеет тип Expr. Для ясности мы будем всегда писать имена типов с прописной буквы, а имена значений - со строчной. 

3а) Равенство (эта-правило):

    expr1 == expr2 

устанавливает синтаксическую взаимозаменяемость двух значений, имеющих одинаковый тип

3б) Правило вывода (бета-правило)

    expr1 := expr2

устанавливает взаимозаменяемость и, кроме того, говорит нам, что при проведении вычислений expr1 должно быть заменено на expr2. 

Также мы будем применять горизонтальную черту для разделения исходных условий и того, что из них следует:

     T type
     ---------------
     T->T type
     i: T->T

     T type 
     x: T
     ---------------
     i(x) := x

# Функции

Прежде, чем мы введём хотя бы один тип, имеющий хотя бы одного представителя, следует описать два важнейших механизма порождения новых типов из уже имеющихся. 

    A type 
    B type
    ----------------
    A->B type

    f: A->B
    a: A
    ----------------
    f(a): B

    ??? Unique - how?!

Как это следует читать:
Для любых типов А и Б существует тип (тотальная) функция из А в Б. Для любой функции из А в Б и любого аргумента а типа А, существует значение функции для этого аргумента, причём оно имеет тип Б". 

***Упражнение 1.** Используя язык суждений, запишите бета-правило для композиции функций g и f.*

# Сумма типов

    A type
    B type
    ----------------
    A+B type

    a: A
    B type
    ----------------
    inl(a): A+B

    b: B
    A type
    ----------------
    inr(b): A+B

    ??? uniqueness!

# Упорядоченная пара

    A type
    B type
    ----------------
    A*B type
    fst: A*B->A
    snd: A*B->B

    a: A
    b: B
    ----------------
    pair(a,b): A*B
    fst(pair(a,b)) := a
    snd(pair(a,b)) := b

Не забываем уникальность - опять же, тотальность функций fst и snd гарантирует нам, что _ничего_ кроме пар множество пар не содержит:

    p: A*B
    ----------------
    p == pair(fst(p),snd(p))

Вообще говоря, пара выражается через плюс и стрелку. Однако удобно.

# Каррирование. Функции многих аргументов

До сих пор все функции имели ровно один аргумент. Как же записать f(x,y) = z?

    f: A*B->Z
    ----------------
    curry f: A->(B->Z)

    a: A
    b: B
    f: A*B->Z
    ----------------
    curry(f)(a)(b) = f(pair(a,b))



# Про ассоциативность

Вообще говоря, (A+B)+C не обязательно равно A+(B+C). Здесь и далее мы будем считать, что запись A+B+C на самом деле означает A+(B+C), а не наоборот. Это по сути соответствует else if со множеством ветвей. Мы последовательно отсекаем возможности.

Аналогично A->B->C следует трактовать как функцию двух аргументов, а не генератор каких-то значений из какой-то функции. И то же для A*B.

Мы будем считать, что `*`, `+`, `->` расположены по убыванию приоритета, т.е. `A+B*C->D` - это функция в D из A или пары B,C. 

# Тривиальные типы

Юнит, он же 1, он же void - тип с одним элементом. 

    ()
    ----------------
    Unit type
    unit: Unit

    a: Unit
    b: Unit
    ----------------
    a == b

Для хранения значения типа Unit потребно 0 бит (не 1!). Для любого типа T существует одна функция со значением Unit, а именно

    T type
    ----------------
    discard: T->Unit

discard, по сути, означает, что значение не просто нигде не используется, а его можно даже и не вычислять.

Кроме того, существует по одной функции Unit->T для каждого представителя T:

    T type
    t: T
    ----------------
    return t: Unit->T

Их мы впоследствии будем использовать при конструировании более сложных функций. 

Казалось бы, куда проще, однако в дальнейшем нам потребуется ещё тип None (null, undef и иже с ними). Он не имеет *ни одного* представителя:

    ()
    ----------------
    None type

    x: None
    ----------------
    любое утверждение

В конструктивной логике, которую мы используем, нет аксиомы исключённого третьего и, соответственно, нормального способа записать отрицание. Однако мы можем использовать принцип "из ложной посылки следует что угодно". Поэтому, если найдётся хоть один элемент None, у автора сих строк на лбу вырастет рог, выяснится, что Земля стоит на трёх китах, ну и т.д.

Из определения стрелки следует, что

    f: X->None
    x: X
    ----------------
    f(x): None
    любое утверждение

и, следственно, если существует хоть одна функция из X в None, то X само None.

# Конечные/перечислимые типы

Конечно же, Boolean.

    ()
    ----------------
    Boolean := Unit + Unit






